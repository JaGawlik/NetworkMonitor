using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;
using System.Windows.Forms;

namespace NetworkMonitor.Utilities
{
    public static class LocalRulesConfigManager 
    {
        private static readonly string LocalRulesFilePath = Path.Combine(AppConfiguration.ConfigurationManager.GetSetting("SnortInstallationPath"), "rules", "local.rules");

        /// <summary>
        /// Wczytuje reguły Snorta z pliku local.rules.
        /// </summary>
        public static List<SnortLocalRule> LoadLocalRules()
        {
            var rules = new List<SnortLocalRule>();

            if (!File.Exists(LocalRulesFilePath))
            {
                Console.WriteLine($"Plik {LocalRulesFilePath} nie istnieje.");
                return rules;
            }

            var lines = File.ReadAllLines(LocalRulesFilePath);
            foreach (var line in lines)
            {
                if (string.IsNullOrWhiteSpace(line) || line.StartsWith("#")) continue;

                var rule = SnortLocalRule.Parse(line);
                if (rule != null)
                {
                    rules.Add(rule);
                }
            }

            return rules;
        }

        /// <summary>
        /// Zapisuje reguły Snorta do pliku local.rules.
        /// </summary>
        public static void SaveRules(List<SnortLocalRule> rules)
        {
            var lines = new List<string>
            {
                "# Custom Local Rules",
                "# =====================",
                "# Generated by NetworkMonitor",
                ""
            };

            foreach (var rule in rules)
            {
                lines.Add(rule.ToString());
            }

            File.WriteAllLines(LocalRulesFilePath, lines);
            Console.WriteLine($"Zapisano {rules.Count} reguł do {LocalRulesFilePath}");
        }

        /// <summary>
        /// Dodaje nową regułę do pliku local.rules.
        /// </summary>
        public static void AddRule(string action, string protocol, string sourceIp, string sourcePort, string direction, string destinationIp, string destinationPort, string message, int sid, int rev)
        {
            var rules = LoadLocalRules();

            if (rules.Any(r => r.Sid == sid))
            {
                Console.WriteLine($"Reguła o SID={sid} już istnieje! Nie dodano reguły.");
                return;
            }

            var newRule = new SnortLocalRule
            {
                Action = action,
                Protocol = protocol,
                SourceIp = sourceIp,
                SourcePort = sourcePort,
                Direction = direction,
                DestinationIp = destinationIp,
                DestinationPort = destinationPort,
                Message = message,
                Sid = sid,
                Rev = rev
            };

            rules.Add(newRule);
            SaveRules(rules);
            Console.WriteLine($"Dodano regułę: {newRule}");
        }

        /// <summary>
        /// Usuwa regułę o podanym SID.
        /// </summary>
        public static void RemoveRule(int sid)
        {
            var rules = LoadLocalRules();
            var updatedRules = rules.Where(r => r.Sid != sid).ToList();

            if (rules.Count == updatedRules.Count)
            {
                Console.WriteLine($"Nie znaleziono reguły o SID={sid}.");
                return;
            }

            SaveRules(updatedRules);
            Console.WriteLine($"Usunięto regułę z SID={sid}.");
        }
    }

    /// <summary>
    /// Klasa reprezentująca regułę Snorta.
    /// </summary>
    public class SnortLocalRule
    {
        public string Action { get; set; } = "alert";
        public string Protocol { get; set; } = "tcp";
        public string SourceIp { get; set; } = "any";
        public string SourcePort { get; set; } = "any";
        public string Direction { get; set; } = "->";
        public string DestinationIp { get; set; } = "any";
        public string DestinationPort { get; set; } = "any";
        public string Message { get; set; }
        public int Sid { get; set; }
        public int Rev { get; set; }
        public int? IType { get; set; }
        public string ThresholdType { get; set; }
        public string ThresholdTrack { get; set; }
        public int? ThresholdCount { get; set; }
        public int? ThresholdSeconds { get; set; }
        public string Flags { get; set; }
        public string DSize { get; set; }
        public string DetectionTrack { get; set; }
        public int? DetectionCount { get; set; }
        public int? DetectionSeconds { get; set; }
        public string Content { get; set; }
        public int? Depth { get; set; }
        public bool NoCase { get; set; }

        public string FormattedRule => ToString();

        public override string ToString()
        {
            var options = new List<string>
        {
            $"msg:\"{Message}\"",
            $"sid:{Sid}",
            $"rev:{Rev}"
        };

            if (IType.HasValue) options.Add($"itype:{IType}");
            if (!string.IsNullOrEmpty(Flags)) options.Add($"flags:{Flags}");
            if (!string.IsNullOrEmpty(DSize)) options.Add($"dsize:{DSize}");
            if (!string.IsNullOrEmpty(Content)) options.Add($"content:\"{Content}\"");
            if (Depth.HasValue) options.Add($"depth:{Depth}");
            if (NoCase) options.Add("nocase");
            if (!string.IsNullOrEmpty(ThresholdType))
            {
                options.Add($"threshold:type {ThresholdType}, track {ThresholdTrack}, count {ThresholdCount}, seconds {ThresholdSeconds}");
            }
            if (!string.IsNullOrEmpty(DetectionTrack))
            {
                options.Add($"detection_filter:track {DetectionTrack}, count {DetectionCount}, seconds {DetectionSeconds}");
            }

            return $"{Action} {Protocol} {SourceIp} {SourcePort} {Direction} {DestinationIp} {DestinationPort} ({string.Join("; ", options)});";
        }

        public static SnortLocalRule Parse(string ruleLine)
        {
            var regexPattern = @"^(?<action>\w+)\s+(?<protocol>\w+)\s+(?<srcip>[^\s]+)\s+(?<srcport>[^\s]+)\s+(?<direction><>|->)\s+(?<dstip>[^\s]+)\s+(?<dstport>[^\s]+)\s+\((?<options>.+)\)$";

            var match = Regex.Match(ruleLine, regexPattern);
            if (!match.Success)
            {
                Console.WriteLine($"Błąd parsowania reguły: {ruleLine}");
                return null;
            }

            string options = match.Groups["options"].Value;

            var msgMatch = Regex.Match(options, @"msg:\""(?<message>[^\""]+)\""");
            var sidMatch = Regex.Match(options, @"sid:(?<sid>\d+)");
            var revMatch = Regex.Match(options, @"rev:(?<rev>\d+)");
            var itypeMatch = Regex.Match(options, @"itype:(?<itype>\d+)");
            var thresholdMatch = Regex.Match(options, @"threshold:type (?<threshold_type>\w+), track (?<threshold_track>\w+), count (?<threshold_count>\d+), seconds (?<threshold_seconds>\d+)");
            var flagsMatch = Regex.Match(options, @"flags:(?<flags>[^\s;]+)");
            var dsizeMatch = Regex.Match(options, @"dsize:(?<dsize>[^\s;]+)");
            var detectionFilterMatch = Regex.Match(options, @"detection_filter:track (?<detection_track>\w+), count (?<detection_count>\d+), seconds (?<detection_seconds>\d+)");
            var contentMatch = Regex.Match(options, @"content:\""(?<content>[^\""]+)\""");
            var depthMatch = Regex.Match(options, @"depth:(?<depth>\d+)");
            var nocaseMatch = Regex.Match(options, @"nocase");

            return new SnortLocalRule
            {
                Action = match.Groups["action"].Value,
                Protocol = match.Groups["protocol"].Value,
                SourceIp = match.Groups["srcip"].Value,
                SourcePort = match.Groups["srcport"].Value,
                Direction = match.Groups["direction"].Value,
                DestinationIp = match.Groups["dstip"].Value,
                DestinationPort = match.Groups["dstport"].Value,
                Message = msgMatch.Success ? msgMatch.Groups["message"].Value : "",
                Sid = sidMatch.Success ? int.Parse(sidMatch.Groups["sid"].Value) : 0,
                Rev = revMatch.Success ? int.Parse(revMatch.Groups["rev"].Value) : 0,
                IType = itypeMatch.Success ? int.Parse(itypeMatch.Groups["itype"].Value) : (int?)null,
                ThresholdType = thresholdMatch.Success ? thresholdMatch.Groups["threshold_type"].Value : "",
                ThresholdTrack = thresholdMatch.Success ? thresholdMatch.Groups["threshold_track"].Value : "",
                ThresholdCount = thresholdMatch.Success ? int.Parse(thresholdMatch.Groups["threshold_count"].Value) : (int?)null,
                ThresholdSeconds = thresholdMatch.Success ? int.Parse(thresholdMatch.Groups["threshold_seconds"].Value) : (int?)null,
                Flags = flagsMatch.Success ? flagsMatch.Groups["flags"].Value : "",
                DSize = dsizeMatch.Success ? dsizeMatch.Groups["dsize"].Value : "",
                DetectionTrack = detectionFilterMatch.Success ? detectionFilterMatch.Groups["detection_track"].Value : "",
                DetectionCount = detectionFilterMatch.Success ? int.Parse(detectionFilterMatch.Groups["detection_count"].Value) : (int?)null,
                DetectionSeconds = detectionFilterMatch.Success ? int.Parse(detectionFilterMatch.Groups["detection_seconds"].Value) : (int?)null,
                Content = contentMatch.Success ? contentMatch.Groups["content"].Value : "",
                Depth = depthMatch.Success ? int.Parse(depthMatch.Groups["depth"].Value) : (int?)null,
                NoCase = nocaseMatch.Success
            };
        }

    }

}
